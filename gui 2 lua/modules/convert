repeat task.wait() until _G.DGLOBAL

local ConvertModule = {}
local PluginSettings;
local RunContext;

local Modules = script.Parent
local SerializeModule = require(Modules:WaitForChild('Serialize'))
local PropertiesModule = require(Modules:WaitForChild('Properties'))
local NotifyModule = require(Modules:WaitForChild('Notify'))

if _G.DGLOBAL and _G.DGLOBAL.UI_CONVERTER then
	PluginSettings = _G.DGLOBAL.UI_CONVERTER.SETTINGS
end

ConvertModule.IsScript = function(instance : Instance)
	if instance:IsA('Script') then return true end
	if instance:IsA('LocalScript') then return true end
	if instance:IsA('ModuleScript') then return true end
	
	return false
end

ConvertModule.SupportedType = function(instance : Instance)
	if PropertiesModule[instance.ClassName] then 
		return true
	end
	
	return false
end

ConvertModule.Convert = function(instance : Instance, parameters: {})
	if #instance:GetDescendants() + 1 >= 200 and PluginSettings.USE_LOCAL then
		NotifyModule.Notify('Error', 'Limit of 200 local variables reached. Please disable "Use Local"', 6)
		return
	end
	
	assert(_G.DGLOBAL.UI_CONVERTER.PROCESS, 'Could not find process.')
	
	local PROCESS = _G.DGLOBAL.UI_CONVERTER.PROCESS
	PROCESS.COUNTS = { TOTAL = 0, FAILURES = 0 }
	PROCESS.SCRIPTS = {}
	PROCESS.FONTS = {}
	
	local Chunk = '--! file generated by dooms GUI TO LUA : V2.0.0 \n';
	
	local function AppendToChunk(Text : string)
		Chunk = string.format(Chunk..Text)
	end

	AppendToChunk('\n-- SETTINGS:')
	AppendToChunk('\n---------------------------------')
	AppendToChunk(`\n-- Method: "{PluginSettings.CONVERSION_METHOD}"`)
	AppendToChunk(`\n-- Compression: {not PluginSettings.NEWLINES}`)
	AppendToChunk(`\n-- Comments: {PluginSettings.COMMENTS}`)
	AppendToChunk(`\n-- Shorten Vars: {PluginSettings.SHORTEN_VARIABLES}`)
	AppendToChunk(`\n-- Use local: {PluginSettings.USE_LOCAL}`)
	AppendToChunk(`\n-- Use table: {PluginSettings.USE_TABLE}\n`)
	
	if PluginSettings.USE_TABLE then
		Chunk = string.format(Chunk .. `{PluginSettings.TABLE_NAME} = \{} \n\n`)
	end
	
	if PluginSettings.CONVERSION_METHOD == 'Custom' then
		Chunk = string.format(Chunk .. [[
%sfunction %s(class : string, properties : {})
	local i

	local madeInstance, errorMessage = pcall(function()
		i = Instance.new(class)	
	end)

	if not madeInstance then
		return error(errorMessage, 99)
	end

	for property, value in properties do
		local _, err = pcall(function()
			i[property] = value
		end)
		
		if err then 
			return warn(`Problem adding instance: {err}`) 
		end
	end

	return i or nil
end
]], true and '\n--[[		FUNCTIONS		]]--\n' or '', PluginSettings.FUNCTION_NAME) .. string.format(true and '\n--[[		INSTANCES		]]--' or '')
	end
	
	--# Make font table to process custom fonts
	for Index, Descendant in instance:GetDescendants() do
		if ConvertModule.IsScript(Descendant) then
			table.insert(PROCESS.SCRIPTS, Descendant)
		end
		
		pcall(function()
			if Descendant.Font and Descendant.FontFace and Descendant.Font == Enum.Font.Unknown then
				local FontPath = Descendant.FontFace.Family
				local FontName = Descendant.FontFace.Family
				
				FontName = FontName:gsub(".+/([^/]+)%.json$", "%1")
				FontName = FontName:gsub('rbxassetid://', '')
				PROCESS.FONTS[FontName] = FontPath
			end
		end)
	end

	RunContext = Enum.RunContext.Client
	instance:SetAttribute('DGLOBAL_ANCESTOR', true)
	Chunk = Chunk .. SerializeModule.Serialize(instance, {})

	--# Serialize all descendants
	for Index, Descendant in instance:GetDescendants() do
		if ConvertModule.SupportedType(Descendant) and not ConvertModule.IsScript(Descendant) then
			Chunk = Chunk .. SerializeModule.Serialize(Descendant, {})
		end
	end
	
	--# Serialize scripts
	if #PROCESS.SCRIPTS > 0 then
		AppendToChunk('\n\n--[[		 SCRIPTS		]]--')
	end
	
	for Index, Script in (PROCESS.SCRIPTS) do
		if Script.RunContext == Enum.RunContext.Server then
			RunContext = Enum.RunContext.Server
		end
		
		if Script:IsA('LocalScript') or Script:IsA('ModuleScript') then
		else
			RunContext = Enum.RunContext.Server
		end
		
		if ConvertModule.IsScript(Script) then
			local Serialized, VarName = SerializeModule.Serialize(Script, {})
			Chunk = Chunk .. (Index > 1 and '\n' or '') .. Serialized
			Chunk = string.format(Chunk .. [[

task.spawn(function()
	local script = %s
	%s
end)]], VarName, Script.Source)
		end
	end

	--# Set descendants to normal state
	for Index, Descendant in instance:GetDescendants() do
		Descendant:SetAttribute('DGLOBAL_ANCESTOR', nil)
		Descendant:SetAttribute('DGLOBAL_COUNT', nil)
		Descendant:SetAttribute('DGLOBAL_CNAME', nil)
	end

	warn('Finished converting.')
	warn(`âœ… Converted {PROCESS.COUNTS.TOTAL - PROCESS.COUNTS.FAILURES}/{PROCESS.COUNTS.TOTAL} instances successfully.`)
	return Chunk, RunContext
end

return ConvertModule
